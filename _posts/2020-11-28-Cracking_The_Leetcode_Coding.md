---
layout: post
title: Cracking the Leetcode Coding
description: Summary of how I prepare for the coding screening in Leetcode
date: 2020-11-28
tags: coding, Leetcode, Python
comments_id: 23
---

If you want to get a data scientist or software engineer job in the U.S., coding screening is usually an essential step you have to pass before being invited for an onsite interview. Most people use [Leetcode](www.leetcode.com) as a major resource to practice and prepare coding interviews. It is hard even for industry veterans, not to mention engineering or data science newbies. I started to program in Python from zero in 2016 --- that is when I heard of Leetcode for the first time. I started to practice Leetcode in 2017, and on-and-off until now. It is only when I spent about three months full-time on Leetcode recently that I finally got a taste of success in cracking the Leetcode coding.

Below is a screenshot of my Leetcode premium account:

![](/assets/2020-11-30-19-56-22.png)

Yes, I practiced all these problems THREE times.

# Round 1
Round 1 was done by systematically review and practice different types of data structures and algorithms. Here are the categories I use to divide the coding problems:

- Binary Tree & Binary Search Tree
- Sorted Array
- Binary Search
- Linked List
- Combination & Permutation
- Dynamic Programming
    - Matrix DP
    - Subsequence
    - Substring
    - Two sequences/strings
    - Backpack
    - Others
- High Frequency
- Data Structure
    - Linear Data Structure
        - Queue
        - Stack
        - Hash
    - Tree Data Structure
        - Heap 
        - Trie
        - Graph

The above categories are based on a mixture of **problem frequency and difficulty.** Therefore, algorithms and data structures are mixed up. For example, breadth-first or depth-first search is not listed alone, but rather showing up in multiple categories as they can be applied to various problems.

My focus in this round is to familarize myself with different types of data structures and algorithms, and come up with **one optimal solution for each problem**.

# Round 2

In this round, I set up a [GitHub repository](https://github.com/CathyQian/Data-Structures-and-Algorithms/tree/master/AllSolutions) to host all the problems I have practiced and organized them by **importance** (see full list [here](https://github.com/CathyQian/Data-Structures-and-Algorithms/blob/master/Organize%20by%20Categories.md)).

- Binary Search
- Binary Tree
- Bread-First Search and Depth First Search
- Combination & Permutation
- String Operations
- Linked List
- Array
- Heap, Trie, Stack, Graph and Hashmap
- Dynamic Programming

My focus in this round is to find **more than one solutions for each problem**, and compare their time and space complexity.

# Round 3

I organized problems by companies this round. Problems under each company are all found online. The advantage of this organization is there is no longer hint about what data structures or algorithms to use in each category, so I need to pick the optimal choices from my toolbox. This round really helped me get familiar with different types of algorithms and data structures, as well when to use them appropriately. 

My focus in this round is to **code up an optimal and bugfree solution in 20 min for easy and medium level problems and 30 min for hard problems**.

# What else?

When I first started, I spend time here and there to practice, and the progress is quite slow. When I start to do it in full time, I devote at least four hours practicing every day including weekends and I can really feel my progress. So one important lesson learned: **practice a couple of fixed hours EVERY day without interruption**.

I realized I was able to pass most coding screenings after these three rounds. However, it's quite easy to go backwards. For example, if I pause practicing for a week, many problems seems foreign to me. Therefore, I try to **practice a couple of problems every day to keep my brain fresh**, even when I am not actively looking for a new role.